# -*- coding: utf-8 -*-
"""API_Consumption_Map.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w7IWSD9d-TL2aFILAf8_yQzidYC603Xq
"""

import pandas as pd
import requests
from dash import Dash, dcc, html, Input, Output
import plotly.express as px

# API consumption using BreatheLondon's API
API_key = "AIzaSyCO8yvEqQ8_T7xqBH73Iyes62nu4AtesP4"
# The metadata for list sensors will be used to place markers on the map
# Sensor data is to colour code the markers and show the readings
List_sensors_URL = "https://breathe-london-7x54d7qf.ew.gateway.dev/ListSensors"
Sensor_data_URL = "https://breathe-london-7x54d7qf.ew.gateway.dev/SensorData"
# Creating a dict of http headers to send a request to the Breathe London server to get what I need from the API
# Following the website (Breathe London) they said I need 2 headers to call the metadata
headers = {
    "X-API-KEY": API_key,
    "Content-Type": "application/json"
}

# Now I can request for json metadata
# I can check if the requests is working through the 2nd line
def get_metadata():
  r = requests.get(List_sensors_URL, headers = headers, timeout = 60)
  r.raise_for_status()
# Since the json file isn't in the correct format for python, I have to convert it into the proper dict that python understands
  return pd.DataFrame(r.json())

# Small EDA to see if the above is running smoothly, the features in the metadata, and number of sensors they have
df_sensors = get_metadata()
print(len(df_sensors))
print(df_sensors.columns.tolist())


# Using the sensor data url to call the necessary latest readings which is PM2.5 & NO2
def sensor_readings(species):
  parameters = {"Species": species}
  readings_data = requests.get(Sensor_data_URL, headers = headers, timeout = 60, params= parameters)
  readings_data.raise_for_status()
# Since the json file isn't in the correct format for python, I have to convert it into the proper dict that python understands
  return pd.DataFrame(readings_data.json())

# Small EDA to see if the above is running smoothly, the features in the metadata, and number of sensors they have
df_PM25 = sensor_readings("PM25")
df_NO2 = sensor_readings("NO2")
print("PM2.5 Readings", len(df_PM25))
print("NO2 Readings", len(df_NO2))

# Formatting the data I've pulled from sensor readings into a proper table by school
def latest_by_school(df, value_name):
  # I'm keeping only the features required to ...
  df =df[["SiteCode","ScaledValue","DateTime"]].copy()
  # This converts the str DateTime pulled from the API to an actual datetime format
  # In case some of the string cant be converted I used errors so that it will not crash the code
  df["DateTime"] = pd.to_datetime(df["DateTime"], errors = "coerce", utc = True)
  df["ScaledValue"] = pd.to_numeric(df["ScaledValue"], errors = "coerce")

  # Now I want to keep the latest readings per sensor per site code (school)
  # Tail (1) gives me the last row from each group which is the latest reading
  df = df.sort_values("DateTime").groupby("SiteCode").tail(1)
  # After doing so, I will put it into a table that tells the readings per site
  return df[["SiteCode","ScaledValue"]].rename(columns = {"ScaledValue":value_name})

df_latestPM25 = latest_by_school(df_PM25, "PM25")
df_latestNO2 = latest_by_school(df_NO2, "NO2")

# To. merge both tables so it creates 1 whole table with both air pollutant readings
# SiteCode is the primary key
df = (
    df_sensors
    .merge(df_latestPM25, on = "SiteCode", how = "left")
    .merge(df_latestNO2, on = "SiteCode", how = "left")
    )

print(df[["SiteCode","Latitude", "Longitude", "SiteName","PM25","NO2"]].head())

# Now I will create the boundaries of each pollutant, NO2 & PM2.5
# I got the pollutant boundaries from DEFRA
Pollutant_boundaries = {
    "PM25":{"max_green": 35, "max_yellow": 53, "max_red": 70},
    "NO2":{"max_green": 200, "max_yellow": 400, "max_red": 600}
}

# Since I've created the boundaries, the next stage is to convert the numbers to colours by creating a function
# This will then be called in the map creation to show the different pollutant level

def colour_code(value,species):
  if pd.isna(value):
    return "Unknown"
  if species not in Pollutant_boundaries:
    return "Unknown"
  limits = Pollutant_boundaries[species]

  if value <= limits["max_green"]:
    return "green"
  elif value <= limits["max_yellow"]:
    return "yellow"
  else:
    return "red"

# Now I am ready to create the map
def create_map(df, species):
  df = df.copy()
  #Ensuring the coordinates are in the correct form and dropping any NaN vals
  df["Latitude"] = pd.to_numeric(df["Latitude"], errors = "coerce")
  df["Longitude"] = pd.to_numeric(df["Longitude"], errors = "coerce")
  df = df.dropna(subset = ["Latitude", "Longitude"])

  df["colour_code"] = df[species].apply(lambda v: colour_code(v, species))

  # Creating the colours on the map
  colour_landmark = {"green":"green", "yellow":"yellow", "red":"red", "Unknown":"lightgray"}

  fig = px.scatter_mapbox(
      df,
      lat = "Latitude",
      lon = "Longitude",
      color = "colour_code",
      color_discrete_map = colour_landmark,
      hover_name = "SiteName",
      # This is to call all the data I want to show when the mouse hovers/click over a landmark.
      custom_data = ["SiteCode", "SiteName", "PM25", "NO2", "colour_code"],
      hover_data = {
          "SiteCode": True,
          "Latitude": False,
          "Longitude": False,
          "colour_code": True,
          species: True
      },
      zoom = 10,
      height = 600
  )

  fig.update_traces(marker = {"size":11})
  fig.update_layout(
      mapbox_style = "open-street-map",
      # This removes white spaces around the map
      margin = dict(l = 0, r = 0, t = 0, b = 0),
      legend_title = "Air Quality"
  )
  return fig

# Now I can create the dash app
# This created the Dash app where all the layouts and callbacks are registered
app = Dash(__name__)
# This helps it to run in Render
server = app.server

app.layout = html.Div(
    style = {"maxWidth": "1200px", "margin": "0 auto"},
    # All the components created in children will be seen on the platform
    children = [
        dcc.Dropdown(
            # This is the interactive filter for the user to select the pollutant she wants to view.
            id = "species_dropdown",
            options = [
                {"label": "PM2.5", "value": "PM25"},
                {"label": "NO2", "value": "NO2"}
            ],
            # This is the auto pollutant that will be shown when Dash runs.
            value = "PM25",
            clearable = False,
            style = {"width": "200px"}
            ),
        dcc.Graph(id = "map"),

        html.H4("Sensor selected"),
        # This is where the sensor details will appear after clicking a landmark.
        html.Div(
            id = "selected_sensor",
            style ={
                "border": "thin lightgrey solid",
                "padding": "10px",
                "borderRadius": "5px",
      },
    ),
  ],
)

# This function is in case any of the reading are NaN and helps format the readings
def fmt(x):
    if x is None or (isinstance(x, float) and pd.isna(x)):
        return "No data"
    try:
        return f"{float(x):.1f}"
    except Exception:
        return str(x)

#Creating the map and clickable feature
# When the user interacts with the filter function created above, the app calls the function and then it will show on the platform.
@app.callback(
    Output("map", "figure"),
    Input("species_dropdown", "value")
)
def update_map(species):
  return create_map(df, species)
# This is when the user clicks a landmark, then the pollutant readings will come out
@app.callback(
    Output("selected_sensor", "children"),
    # ClickData is when the app calls the coordinates that links the landmark to the specific data
    Input("map", "clickData"),
)

def display_sensor_deets(clickData):
  if clickData is None:
    return "Click on a marker."
  site_code, site_name, PM25, NO2, colour_code = clickData["points"][0]["customdata"]
  # This is the output of the above callback that will be shown on the platform
  return html.Ul([
        html.Li([html.B("Site Code: "), site_code]),
        html.Li([html.B("PM2.5: "), fmt(PM25)]),
        html.Li([html.B("NO2: "), fmt(NO2)]),
        html.Li([html.B("Air Quality Status: "), str(colour_code).capitalize()]),
    ])

if __name__ == "__main__":
  app.run(debug=True)